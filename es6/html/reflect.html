<!DOCTYPE html>
<html>

<head>
    <title>es6新性能</title>
    <meta charset="utf-8">
    <meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
    <meta content="yes" name="apple-mobile-web-app-capable">
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <meta content="telephone=no" name="format-detection">
    <meta content="email=no" name="format-detection">
    <script>
    window.PointerEvent = void 0
    </script>
    <script type="text/javascript" src="../static/js/plug/flexible.debug.js"></script>
    <link rel="stylesheet" href="../static/css/home.css">
</head>

<body class="bg_body">
    <div id="wap">
        <header>
            <h2>es6新性能-Reflect</h2>
            <a class="title_a a_left back"></a>
        </header>
        <section class="bind descripe">
            <dl>
                <dt class="green">1、概述</dt>
                <dd>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。</dd>
                <dd>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。</dd>
                <dd>修改某些Object方法的返回结果，让其变得更合理。</dd>
                <dd>让Object操作都变成函数行为。</dd>
                <dd>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。</dd>
                <dt class="green">2、静态方法 </dt>
                <dd>Reflect.get(target, name, receiver)</dd>
                <dd>Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。</dd>
                <dd>Reflect.set(target, name, value, receiver) </dd>
                <dd>Reflect.set方法设置target对象的name属性等于value。</dd>
                <dd>Reflect.has(obj, name)方法对应name in obj里面的in运算符。</dd>
                <dd>Reflect.deleteProperty(obj, name)方法等同于delete obj[name]，用于删除对象的属性。</dd>
                <dd>Reflect.construct(target, args)等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。</dd>
                <dd>Reflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。</dd>
                <dd>Reflect.setPrototypeOf方法用于设置对象的__proto__属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。</dd>
                <dd>Reflect.apply(func, thisArg, args)等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。</dd>
                <dd>Reflect.defineProperty(target, propertyKey, attributes)等同于Object.defineProperty，用来为对象定义属性。</dd>
                <dd>Reflect.getOwnPropertyDescriptor(target, propertyKey) 等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。</dd>
                <dd>Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。</dd>
                <dd>Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</dd>
                <dd>Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。</dd>
                <dt class="green">3、实例：使用 Proxy 实现观察者模式</dt>
                <dd>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</dd>
            </dl>
        </section>
    </div>
    <script src="../static/js/home/reflect.js " type="text/javascript "defer async="true "></script>
</body>

</html>
