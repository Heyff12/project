<!DOCTYPE html>
<html>

<head>
    <title>es6新性能</title>
    <meta charset="utf-8">
    <meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
    <meta content="yes" name="apple-mobile-web-app-capable">
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <meta content="telephone=no" name="format-detection">
    <meta content="email=no" name="format-detection">
    <script>
    window.PointerEvent = void 0
    </script>
    <script type="text/javascript" src="../static/js/plug/flexible.debug.js"></script>
    <link rel="stylesheet" href="../static/css/home.css">
</head>

<body class="bg_body">
    <div id="wap">
        <header>
            <h2>Class 的继承</h2>
            <a class="title_a a_left back"></a>
        </header>
        <section class="bind descripe">
            <dl id="dl_clear">
                <dt class="green">1、简介</dt>
                <dd>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</dd>
                <dd>super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</dd>
                <dd>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</dd>
                <dd>先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</dd>
                <dt class="green">2、Object.getPrototypeOf()</dt>
                <dd>Object.getPrototypeOf方法可以用来从子类上获取父类。</dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dt class="green">3、super 关键字</dt>
                <dd>super这个关键字，既可以当作函数使用，也可以当作对象使用。</dd>
                <dd>super作为函数调用时，代表父类的构造函数。</dd>
                <dd>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</dd>
                <dd>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</dd>
                <dd>ES6 规定，通过super调用父类的方法时，super会绑定子类的this。</dd>
                <dt class="green">4、类的 prototype 属性和__proto__属性</dt>
                <dd>Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。</dd>
                <dd>（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。</dd>
                <dd>（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</dd>
                <dd>作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。</dd>
                <dd>extends 的继承目标------------------</dd>
                <dd>extends关键字后面可以跟多种类型的值。</dd>
                <dd>class B extends A {}</dd>
                <dd>上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。</dd>
                <dd>实例的 __proto__ 属性------</dd>
                <dd>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。</dd>
                <dt class="green">5、原生构造函数的继承</dt>
                <dd>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</dd>
                <dd>Boolean();Number();String();Array();Date();Function();RegExp();Error();Object()</dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dt class="green">6、Mixin 模式的实现</dt>
                <dd>Mixin 模式指的是，将多个类的接口“混入”（mix in）另一个类。它在 ES6 的实现如下。</dd>
                <dd></dd>
                <dd></dd>
            </dl>
        </section>
    </div>
    <script src="../static/js/home/class2.js " type="text/javascript "defer async="true "></script>
    <script type="text/javascript">
    </script>
</body>

</html>
