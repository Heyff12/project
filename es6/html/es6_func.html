<!DOCTYPE html>
<html>

<head>
    <title>es6新性能</title>
    <meta charset="utf-8">
    <meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
    <meta content="yes" name="apple-mobile-web-app-capable">
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <meta content="telephone=no" name="format-detection">
    <meta content="email=no" name="format-detection">
    <script>
    window.PointerEvent = void 0
    </script>
    <script type="text/javascript" src="../static/js/plug/flexible.debug.js"></script>
    <link rel="stylesheet" href="../static/css/home.css">
</head>

<body class="bg_body">
    <div id="wap">
        <header>
            <h2>es6新性能-函数的扩展</h2>
            <a class="title_a a_left back"></a>
        </header>
        <section class="bind descripe">
            <dl>
                <dt class="green">1、函数参数的默认值</dt>
                <dd>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</dd>
                <dd>参数变量是默认声明的，所以不能用let或const再次声明。</dd>
                <dd>使用参数默认值时，函数不能有同名参数。</dd>
                <dd>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</dd>
                <dd>如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</dd>
                <dd>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</dd>
                <dd>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。</dd>
                <dd>这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</dd>
                <dd>可以将参数默认值设为undefined，表明这个参数是可以省略的。</dd>
                <dt class="green">2、rest 参数 </dt>
                <dd>ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</dd>
                <dd>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</dd>
                <dd>函数的length属性，不包括 rest 参数。</dd>               
                <dt class="green">3、扩展运算符</dt>
                <dd>扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</dd>
                <dd>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</dd>
                <dd>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</dd>
                <dd>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</dd>
                <dd>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</dd>
                <dt class="green">4、严格模式</dt>
                <dd>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</dd>
                <dt class="green">5、name 属性</dt>
                <dd>函数的name属性，返回该函数的函数名。</dd>
                <dd>ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。</dd>
                <dt class="green">6、箭头函数</dt>
                <dd>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</dd>
                <dd>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</dd>
                <dd>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</dd>
                <dd>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</dd>
                <dd>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</dd>
                <dd>(3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</dd>
                <dd>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</dd>
                <dt class="green">7、绑定 this</dt>
                <dd>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</dd>
                <dt>8、尾调用优化</dt>
                <dd>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</dd>
                <dd>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</dd>
                <dd>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</dd>
            </dl>
        </section>
    </div>
    <!-- <script src="../static/js/require.2.1.11.min.js " type="text/javascript " data-main="../static/js/home/str.js" defer async="true "></script> -->
    <script src="../static/js/home/func.js " type="text/javascript "defer async="true "></script>
</body>

</html>
