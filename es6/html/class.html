<!DOCTYPE html>
<html>

<head>
    <title>es6新性能</title>
    <meta charset="utf-8">
    <meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
    <meta content="yes" name="apple-mobile-web-app-capable">
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <meta content="telephone=no" name="format-detection">
    <meta content="email=no" name="format-detection">
    <script>
    window.PointerEvent = void 0
    </script>
    <script type="text/javascript" src="../static/js/plug/flexible.debug.js"></script>
    <link rel="stylesheet" href="../static/css/home.css">
</head>

<body class="bg_body">
    <div id="wap">
        <header>
            <h2>Class 的基本语法</h2>
            <a class="title_a a_left back"></a>
        </header>
        <section class="bind descripe">
            <dl id="dl_clear">
                <dt class="green">1、简介</dt>
                <dd>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。</dd>
                <dd>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</dd>
                <dd>注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</dd>
                <dd>ES6 的类，完全可以看作构造函数的另一种写法。</dd>
                <dd>类的数据类型就是函数，类本身就指向构造函数。</dd>
                <dd>构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。</dd>
                <dd>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。</dd>
                <dd>类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</dd>
                <dt class="green">2、严格模式</dt>
                <dd>ES6 实际上把整个语言升级到了严格模式。</dd>
                <dt class="green">3、constructor 方法</dt>
                <dd>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。</dd>
                <dd>一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</dd>
                <dd>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</dd>
                <dd>类必须使用new调用，否则会报错。</dd>
                <dt class="green">4、类的实例对象</dt>
                <dd>与 ES5 一样，类的所有实例共享一个原型对象。</dd>
                <dd>这也意味着，可以通过实例的__proto__属性为“类”添加方法。</dd>
                <dd>__proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的JS引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</dd>
                <dt class="green">5、Class 表达式</dt>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dt class="green">6、不存在变量提升</dt>
                <dd>类使用在前，定义在后，这样会报错</dd>
                <dt class="green">7、私有方法</dt>
                <dd>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</dd>
                <dd>一种做法是在命名上加以区别</dd>
                <dd>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</dd>
                <dd>利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dt class="green">8、私有属性</dt>
                <dd>为class加了私有属性。方法是在属性名之前，使用#表示。</dd>
                <dd>私有属性与实例的属性是可以同名的</dd>
                <dd></dd>
                <dd></dd>
                <dt class="green">9、this 的指向</dt>
                <dd>类的方法内部如果含有this，它默认指向类的实例。</dd>
                <dd>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。</dd>
                <dd>另一种解决方法是使用箭头函数。</dd>
                <dd>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</dd>
                <dt class="green">10、name 属性</dt>
                <dd>name属性总是返回紧跟在class关键字后面的类名。</dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dt class="green">11、Class 的取值函数（getter）和存值函数（setter）</dt>
                <dd>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dt class="green">12、Class 的 Generator 方法</dt>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
                <dt class="green">13、Class 的静态方法</dt>
                <dd>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</dd>
                <dd>父类的静态方法，可以被子类继承。</dd>
                <dd>静态方法也是可以从super对象上调用的。</dd>
                <dd></dd>
                <dt class="green">14、Class 的静态属性和实例属性</dt>
                <dd>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</dd>
                <dd>因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</dd>
                <dd>（1）类的实例属性</dd>
                <dd>（2）类的静态属性</dd>
                <dt class="green">15、new.target属性</dt>
                <dd>new是从构造函数生成实例的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在在构造函数之中，返回new命令作用于的那个构造函数。</dd>
                <dd></dd>
                <dd></dd>
                <dd></dd>
            </dl>
        </section>
    </div>
    <script src="../static/js/home/class.js " type="text/javascript "defer async="true "></script>
    <script type="text/javascript">
    </script>
</body>

</html>
