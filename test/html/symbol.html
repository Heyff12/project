<!DOCTYPE html>
<html>

<head>
    <title>es6新性能</title>
    <meta charset="utf-8">
    <meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
    <meta content="yes" name="apple-mobile-web-app-capable">
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <meta content="telephone=no" name="format-detection">
    <meta content="email=no" name="format-detection">
    <script>
    window.PointerEvent = void 0
    </script>
    <script type="text/javascript" src="../static/js/plug/flexible.debug.js"></script>
    <link rel="stylesheet" href="../static/css/home.css">
</head>

<body class="bg_body">
    <div id="wap">
        <header>
            <h2>es6新性能-Symbol</h2>
            <a class="title_a a_left back"></a>
        </header>
        <section class="bind descripe">
            <dl>
                <dt class="green">1、概述</dt>
                <dd>如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。</dd>
                <dd>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</dd>
                <dd>Symbol函数前不能使用new命令，否则会报错</dd>
                <dd>如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</dd>
                <dt class="green">2、作为属性名的 Symbol </dt>
                <dt class="green">3、实例：消除魔术字符串</dt>
                <dd>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。</dd>
                <dt class="green">4、属性名的遍历</dt>
                <dt class="green">5、Symbol.for()，Symbol.keyFor()</dt>
                <dd>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</dd>
                <dd>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</dd>
                <dd>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</dd>
                <dd>如果只有一个参数，Object.assign会直接返回该参数。</dd>
                <dd>如果该参数不是对象，则会先转成对象，然后返回。</dd>
                <dd>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。</dd>
                <dt class="green">6、属性的可枚举性</dt>
                <dd>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。</dd>
                <dd>Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</dd>
                <dt class="green">7、属性的遍历</dt>
                <dd>for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</dd>
                <dd>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。</dd>
                <dd>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）。</dd>
                <dd>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性。</dd>
                <dd>Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 或字符串，也不管是否可枚举。</dd>
                <dt class="green">8、__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</dt>
                <dd>__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。</dd>
                <dd>无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</dd>
                <dt class="green">9、Object.keys()，Object.values()，Object.entries()</dt>
                <dd>ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</dd>
                <dd>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</dd>
                <dt class="green">10、对象的扩展运算符</dt>
                <dt class="green">11、Object.getOwnPropertyDescriptors()</dt>
                <dd>ES5有一个Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象（descriptor）。</dd>
                <dt class="green">12、Null 传导运算符</dt>
            </dl>
        </section>
    </div>
    <!-- <script src="../static/js/require.2.1.11.min.js " type="text/javascript " data-main="../static/js/home/str.js" defer async="true "></script> -->
    <script src="../static/js/home/symbol.js " type="text/javascript "defer async="true "></script>
</body>

</html>
