<!DOCTYPE html>
<html>

<head>
    <title>es6新性能</title>
    <meta charset="utf-8">
    <meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
    <meta content="yes" name="apple-mobile-web-app-capable">
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <meta content="telephone=no" name="format-detection">
    <meta content="email=no" name="format-detection">
    <script>
    window.PointerEvent = void 0
    </script>
    <script type="text/javascript" src="../static/js/plug/flexible.debug.js"></script>
    <link rel="stylesheet" href="../static/css/home.css">
</head>

<body class="bg_body">
    <div id="wap">
        <header>
            <h2>es6新性能-let const</h2>
            <a class="title_a a_left back"></a>
        </header>
        <section class="bind descripe">
            <dl>
                <dt class="green">1、块级作用域，即{}</dt>
                <dd>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</dd>
                <dt class="green">2、变量提升</dt>
                <dd>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</dd>
                <dt class="green">3、暂时性死区</dt>
                <dd>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。typeof运行时就会抛出一个ReferenceError。</dd>
                <dt class="green">4、不允许重复说明</dt>
                <dd>let不允许在相同作用域内，重复声明同一个变量。</dd>
                <dt class="green">5、do表达式</dt>
                <dd>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</dd>
                <dt class="green">6、const</dt>
                <dd>const声明一个只读的常量。一旦声明，常量的值就不能改变。<br/>const的作用域与let命令相同：只在声明所在的块级作用域内有效。<br/>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br/>const声明的常量，也与let一样不可重复声明。</dd>
                <dt class="green">7、const本质</dt>
                <dd>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。<br/>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</dd>
                <dt class="green">8、ES6 一共有6种声明变量的方法</dt>
                <dd>ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。</dd>
                <dt class="green">9、顶层对象的属性</dt>
                <dd>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。</dd>
                <dd>ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</dd>
                <dt class="green">10、global对象</dt>
                <dd>全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。</dd>
                <dd>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</dd>
                <dd>不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</dd>
            </dl>
        </section>
    </div>
    <script src="../static/js/require.2.1.11.min.js " type="text/javascript " data-main="../static/js/home/es6.js" defer async="true "></script>
</body>

</html>
